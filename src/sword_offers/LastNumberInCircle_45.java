package sword_offers;

/**
 * @author hechuan
 */
public class LastNumberInCircle_45 {

    /**
     * 约瑟夫环问题：
     *
     * 1. 首先定义最初的n个数字（0, 1 , ... , n-1）中最后剩下的数字是关于n和m的方程为f(n,m)。
     * 2. 在这n个数字中，第一个被删除的数字是(m-1)%n，为简单起见记为k = (m-1)%n。那么删除k之后的剩下n-1的数字为0, 1, … , k-1 , k+1, …,
     *    n-1，并且下一个开始计数的数字是k+1。相当于在剩下的序列中，k+1排到最前面，从而形成序列k+1, … , n-1, 0, … k-1。该序列最后剩下的数
     *    字也应该是关于n和m的函数。由于这个序列的规律和前面最初的序列不一样（最初的序列是从0开始的连续序列），因此该函数不同于前面函数，记为
     *    f’(n-1,m)。最初序列最后剩下的数字f(n,m)一定是剩下序列的最后剩下数字f’(n-1,m)，所以f(n,m)=f’(n-1,m)。
     *3. 接下来我们把剩下的的这n-1个数字的序列k+1, … , n-1, 0, …, k-1作一个映射，映射的结果是形成一个从0到n-2的序列：
     *
     *      k+1    ->    0
     *      k+2    ->    1
     *      …
     *      n-1    ->    n-k-2
     *      0      ->    n-k-1
     *      …
     *      k-1    ->   n-2
     * 4. 把映射定义为p，则p(x)= (x-k-1)%n，即如果映射前的数字是x，则映射后的数字是(x-k-1)%n。对应的逆映射是p'(x)=(x+k+1)%n。
     * 5. 由于映射之后的序列和最初的序列有同样的形式，都是从0开始的连续序列，因此仍然可以用函数f来表示，记为f(n-1,m)。根据我们的映射规则，映射
     *    之前的序列最后剩下的数字x = f’(n-1,m) = f(n,m) = p'(y), 其中y表示映射之后最后剩下的数字。由于映射后也是从0开始的，所以可以
     *    用规则 y=f(n-1,m)表示。带入即得 f’(n-1,m) = f(n,m) = p'[f(n-1,m)]=[f(n-1,m)+k+1]%n。把k=(m-1)%n代入得到
     *    f(n,m)=f’(n-1,m)=[f(n-1,m)+m]%n。
     * 6. 经过上面复杂的分析，我们终于找到一个递归的公式。要得到n个数字的序列的最后剩下的数字，只需要得到n-1个数字的序列的最后剩下的数字，并可
     *    以依此类推。当n=1时，也就是序列中开始只有一个数字0，那么很显然最后剩下的数字就是0。我们把这种关系表示为：
     *              { 0                  n=1
     *      f(n,m)= {
     *              { [f(n-1,m)+m]%n     n>1
     *
     * @param n length of the circle
     * @param m target number
     * @return the last remaining number
     */
    public int LastRemaining_Solution(int n, int m) {
        if (n == 0 || m == 0) { return -1; }
        int res = 0;

        for (int i = 2; i <= n; i++) {
            res = (res + m) % i;
        }

        return res;
    }
}
